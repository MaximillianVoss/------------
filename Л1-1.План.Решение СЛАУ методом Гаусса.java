// Results - это перечисление (enum), содержащее возможные результаты после анализа системы уравнений.
// В данном случае, оно определяет пять возможных состояний:
// ENDLESS_SOLUTIONS - Система уравнений имеет бесконечное количество решений.
// DEGENERATE_SYSTEM - Система уравнений вырожденная (например, все уравнения линейно зависимы).
// NO_SOLUTIONS - Система уравнений не имеет решений.
// ONLY_SOLUTION - Система уравнений имеет единственное решение.
// MAY_BE_CONTINUED - Система уравнений может быть дополнена другими уравнениями для получения решения или анализа.
public enum Results {
  ENDLESS_SOLUTIONS,
  DEGENERATE_SYSTEM,
  NO_SOLUTIONS,
  ONLY_SOLUTION,
  MAY_BE_CONTINUED,
}

// Класс Matrix
class Matrix {

  // Матрица
  private double[][] matrixArray;
  // Количество строк
  private int rowAmount;
  // Количество столбцов
  private int columnAmount;
  // Малое значение для проверки на равенство нулю
  private double epsilon;
  private static final int NotFounded = -1;

  // Метод печати матрицы
  public void Print() {
    // Цикл по строкам матрицы
    // Цикл по столбцам матрицы
    // Выводим элементы матрицы в консоль с форматированием
    // Выводим новую строку
    // Выводим пустую строку
  }

  // Инициализация матрицы из файла
  public void Init(String s) throws FileNotFoundException {
    // Создаем объект File с именем файла s
    // Создаем объект Scanner для чтения файла
    // Создаем объект Pattern для разделения строк на элементы
    // Считываем первую строку файла
    // Разделяем строку на элементы и преобразуем их в соответствующие числа
    // Создаем матрицу с заданными размерами
    // Цикл по строкам матрицы
    // Считываем строку
    // Разделяем строку на элементы и преобразуем их в числа
    // Заполняем матрицу данными
    // Закрываем объект Scanner
  }

  // Приведение матрицы к треугольному виду
  public Results MakeTriangle() {
  // Процесс приведения матрицы коэффициентов к треугольному виду состоит из следующих шагов:
  // 1. Проход по каждому столбцу матрицы, начиная с первого столбца:
  //    - Выбираем первый ненулевой элемент в текущем столбце, начиная с текущей строки.
  //    - Если такой элемент не найден, переходим к следующему столбцу.
  // 2. Нахождение строки с максимальным элементом в текущем столбце и перестановка этой строки с первой строкой:
  //    - Ищем строку с максимальным элементом в текущем столбце, начиная с текущей строки.
  //    - Если такая строка найдена, меняем местами текущую строку с найденной строкой.
  //    - Если такая строка не найдена, переходим к следующему столбцу.
  // 3. Деление первой строки на первый элемент, чтобы получить ведущий элемент равным 1:
  //    - Делим все элементы первой строки на значение первого элемента, чтобы получить ведущий элемент равным 1.
  //    - Это позволяет упростить последующие вычисления.
  // 4. Вычитание первой строки, умноженной на коэффициент, из остальных строк, чтобы получить нули под ведущим элементом:
  //    - Для каждой строки, начиная со второй, выполняем следующие операции:
  //      - Вычисляем коэффициент, равный отрицанию элемента текущей строки под ведущим элементом, деленному на ведущий элемент.
  //      - Вычитаем из текущей строки первую строку, умноженную на вычисленный коэффициент.
  //      - Это приводит к обнулению элементов под ведущим элементом в каждой строке.
  // 5. Повторяем шаги 1-4 для следующего столбца, до тех пор, пока все столбцы не будут просмотрены или будет достигнут конец матрицы.
  }

  // Проверка на наличие решений
  public Results CheckSolutions() {
// Процесс проверки решений системы уравнений после приведения матрицы к треугольному виду в методе Гаусса состоит из следующих шагов:
// 1. Проверка на наличие бесконечного количества решений:
//    - Проверяем, есть ли в последнем столбце матрицы нулевой элемент перед последней строкой.
//    - Если такой элемент существует, это указывает на возможность бесконечного количества решений.
//    - Возвращаем результат "Система уравнений имеет бесконечное количество решений".
// 2. Проверка на вырожденность системы уравнений:
//    - Проверяем, равен ли последний элемент последнего столбца матрицы нулю.
//    - Если элемент равен нулю, это указывает на вырожденность системы уравнений.
//    - Возвращаем результат "Система уравнений вырожденная".
// 3. Проверка на отсутствие решений:
//    - Если ни одно из предыдущих условий не выполняется, это означает, что система уравнений имеет единственное решение.
//    - Возвращаем результат "Система уравнений имеет единственное решение".
// 4. Проверка на возможность продолжения:
//    - Если ни одно из предыдущих условий не выполняется, исключая случаи бесконечного количества решений, вырожденности и единственного решения, то это указывает на то, что система уравнений может быть дополнена другими уравнениями для получения дополнительных решений или дальнейшего анализа.
//    - Возвращаем результат "Система уравнений может быть продолжена".
// После выполнения этих проверок мы можем сделать вывод о количестве решений системы уравнений:

// - Если результат "Система уравнений имеет бесконечное количество решений", это означает, что система уравнений содержит бесконечное количество возможных решений.
// - Если результат "Система уравнений вырожденная", это означает, что система уравнений не имеет решений.
// - Если результат "Система уравнений имеет единственное решение", это означает, что система уравнений имеет единственное решение.

// Корректная проверка решений после приведения к треугольному виду помогает определить характер системы уравнений и принять соответствующие дальнейшие действия в алгоритме решения.
  }

  // Нахождение решений
  public double[] FindSolutions() {
    // Создаем массив решений размером rowAmount
    // Цикл по строкам матрицы в обратном порядке
    // Вызываем GetSolution с массивом решений и индексом строки
    // Обновляем значение решения для текущей строки
    // Возвращаем массив решений
  }

  // Создание матрицы
  private void Create(int rowAmount, int columnAmount) {
    // Создаем массив массивов для матрицы
    // Цикл по строкам матрицы
    // Создаем массив элементов для каждой строки
  }

  // Обмен строк с не нулевым элементом
  private boolean SwapFirstNotZeroLine(int lineNumber) {
    // Если элемент на диагонали равен нулю
    // Найти строку с ненулевым элементом на данной позиции
    // Если такой строки нет, вернуть false
    // Иначе, обменять строки местами
    // Вернуть true
  }

  // Найти строку с ненулевым элементом
  private int FindLineWithNotZeroElement(int lineNumber) {
    // Цикл по строкам, начиная с lineNumber
    // Если элемент строки на позиции lineNumber не равен нулю
    // Вернуть индекс строки
    // Вернуть NotFounded
  }

  // Обнуление столбца
  private void MakeColumnZero(int columnNumber) {
    // Устанавливаем индекс строки равным columnNumber
    // Цикл по строкам, начиная с columnNumber
    // Вычисляем множитель для обнуления элемента столбца
    // Вызываем метод MultiplicationAndSubtractionOfLine с множителем, номером итерации и номером строки
    // Увеличиваем индекс строки
  }

  // Поменять строки местами
  private void SwapLines(int firstLine, int secondLine) {
    // Сохраняем ссылку на строку secondLine во временную переменную
    // Заменяем строку secondLine на firstLine
    // Заменяем строку firstLine на временную переменную (бывшую secondLine)
  }

  // Проверка на равенство элемента нулю
  private boolean IsZeroElement(double element) {
    // Сравниваем абсолютное значение элемента с epsilon
    // Возвращаем результат сравнения
  }

  // Умножение и вычитание строк
  private void MultiplicationAndSubtractionOfLine(
    double multiplier,
    int iterationNumber,
    int lineNumber
  ) {
    // Цикл по столбцам матрицы
    // Вычитаем произведение множителя на элемент строки iterationNumber из элемента строки lineNumber
    // Если элемент строки lineNumber равен нулю, устанавливаем его значение в 0
  }

  // Получение решения
  private double GetSolution(double[] solution, int i) {
    // Инициализация переменной для суммы
    // Цикл по строкам матрицы, начиная с i + 1
    // Увеличиваем сумму на произведение текущего решения на соответствующий элемент строки
    // Возвращаем сумму
  }
}

// Класс Main
class Main {

  public static void main(String[] args) {
    // Создаем объект mat типа Matrix
    // Загружаем матрицу из файла "src/Input.txt"
    // В случае ошибки FileNotFoundException, выводим сообщение "FILE NOT FOUND!!!"
    // Выводим матрицу на экран
    // Вызываем метод MakeTriangle для матрицы и сохраняем результат в переменную result
    // Выводим матрицу на экран после преобразования
    // Выводим результат операции (текстовое сообщение) с помощью метода GetResult
    // Если результат равен Results.MAY_BE_CONTINUED
    // Вызываем метод CheckSolutions для матрицы и обновляем переменную result
    // Если результат равен Results.ONLY_SOLUTION
    // Вызываем метод FindSolutions для матрицы и сохраняем результат в массив array
    // Выводим массив решений на экран с помощью метода PrintResult
    // Иначе
    // Выводим результат операции (текстовое сообщение) с помощью метода GetResult
  }

  // Метод вывода результата на экран
  public static void GetResult(Results result) {
    // Используем оператор switch для вывода соответствующего текстового сообщения в зависимости от значения result
  }

  // Метод вывода массива решений на экран
  public static void PrintResult(double[] resultArray) {
    // Выводим текст "Результат: "
    // Цикл по элементам массива resultArray
    // Выводим элемент массива на экран с форматированием
    // Выводим пустую строку
  }
}
