class Polynomial { // Класс для хранения полинома

  // Связный список элементов полинома

  class PolynomialTerm { // внутренний класс для хранения одного элемента полинома
    double coefficient; // Коэффициент элемента полинома
    int degree; // Неотрицательная степень элемента полинома
  }

  //TODO: добавить идентификаторы
  // Сложение полиномов
  Polynomial add(Polynomial other) { //other - полином для сложения с текущим полиномом
    Создать новый объект Polynomial для результата сложения
    Обойти элементы текущего полинома и полинома other
    Для каждого элемента в текущем полиноме:
      Найти элемент с той же степенью в полиноме other
      Если такой элемент существует:
        Сложить коэффициенты элементов
        Добавить полученный элемент в результат, если коэффициент не равен нулю
    Вернуть результат сложения 
  }


 

  // Умножение полиномов
  Polynomial multiply(Polynomial other) { //other - полином для умножения на текущий полином
    Создать новый объект Polynomial для результата умножения
    Обойти элементы текущего полинома:
      Обойти элементы полинома other:
        Умножить коэффициенты элементов и сложить степени
        Добавить полученный элемент в результат
    Свернуть результат, объединяя элементы с одинаковыми степенями и суммируя их коэффициенты
    Удалить элементы с нулевыми коэффициентами
    Вернуть результат умножения
  }

  // Умножение полинома на вещественное число
  Polynomial multiplyByScalar(double scalar) { //scalar - вещественное число для умножения на текущий полином
    Создать новый объект Polynomial для результата умножения
    Обойти элементы текущего полинома:
      Умножить коэффициент элемента на scalar
      Добавить полученный элемент в результат
    Вернуть результат умножения на вещественное число
  }

  // Вычисление значения полинома в точке по правилу Горнера
  double evaluate(double x) { //x - точка, в которой вычисляется значение полинома
    Инициализировать переменную result нулем
    Обойти элементы полинома в обратном порядке:
      Вычислить значение элемента полинома в точке x
      Добавить значение элемента к result
    Вернуть result
  }

  // Вывод полинома на экран
  void print() {
    Обойти элементы полинома:
      Вывести на экран коэффициент и степень каждого элемента с учётом знака и формата вывода
      Пока мы не дойдём до последнего элемента, выводим коэффициент и степень
  }
}

class Grid { // Класс для хранения узлов сетки и значений сеточной функции
  double[] nodes; // Массив узлов сетки
  double[] values; // Массив значений сеточной функции

  // Конструктор класса Grid для выделения памяти
  Grid(int size) {
    Создать массив nodes размером size
    Создать массив values размером size
  }
}

class LagrangePolynomial { // Класс для интерполяционного полинома в форме Лагранжа
  Polynomial polynomial; // Объект класса Polynomial для хранения полинома

  // Конструктор, принимающий grid - объект класса Grid с узлами сетки и значениями сеточной функции
  LagrangePolynomial(Grid grid) {
    Создать новый объект Polynomial для результата
    Используя узлы сетки и значения сеточной функции:
      Построить полином Лагранжа
      Сохранить полученный полином в поле polynomial
  }

  // Метод для вывода полинома на экран
  void print() {
    Вызвать метод print() объекта Polynomial для вывода полинома на экран
  }
}

class Main { // Главный класс с методом main() и форматированным выводом
  public static void main(String[] args) {
    double a = Начало интервала
    double b = Конец интервала
    int points = Количество точек

    Grid grid = Создать объект класса Grid с узлами сетки и значениями сеточной функции размером points
    LagrangePolynomial lagrangePolynomial = Создать объект класса LagrangePolynomial, используя объект Grid для построения полинома

    Вывести полином на экран в экспоненциальном виде с 6 знаками после десятичной точки
    Вывести результаты интерполяции в табличной форме

    // Метод, возвращающий значение для узла сетки
    double f(double x) {
      // ...
      Реализация функции для вычисления значения узла сетки в точке x
    }
  }

  // Вывод результатов интерполяции в табличной форме
  static void printResults(LagrangePolynomial lagrangePolynomial, Grid grid, double a, double b, int points) {
    double step = (b - a) / (points - 1)
    Вывести заголовки столбцов таблицы: "x\t y\t f(x)\t Ln(x)"

    Обойти точки интервала [a; b] с заданным шагом:
      Для каждой точки x от a до b с шагом step:
        Вывести значение x, значение интерполяционного полинома и значение исходной функции f(x) для каждой точки 
        в формате "%.6f\t %.6f\t %.6f\t %.6f"
  }
}


//Примечания:
// лаб3
// КЛАСС ПОЛИНОМА
// Методы написаны общими словами. Важен процесс выполнения! (псевдокод русским языком)
// НАПРИМЕР: в сложении двух полиномов расписываем:
// «пока не закончится один или второй полином, мы сравниваем степени. если степень первого больше степени второго, делаем одно. если они равны, делаем то-то итд.
// !!! Описать подробно! Основа написана.
// Должны определяться проверки.
// НАЧИНАЕМ ВСЕГДА С ОДНОГО:
// Сперва вопрос: мы будем создавать новый полином и добавлять в новый полином, или использовать один из полиномов для того, чтобы сохранять результат. 
// И дальше на основе этого будут разные алгоритмы.
// !!! Должно быть четкое понимание в каждом пункте !!!
// НАПРИМЕР АЛГОРИТМ: если делаем в новый полином. значит будет реализован внешний цикл, в котором одновременно нужно идти по двум полиномам. значит сравниваем степени двух полиномов. если у первого больше второго, копируем член в новый полином, и в первом переходите к следующему элементу. если они равны, мы находим сумму коэффициентов, записываем в новый полином, и в первом и во втором полиноме переходим к следующему. 
// и если степень второго больше, то у второго записываем и двигаем.
// !!!рассматриваем все варианты!!!
// это продолжается до того, пока не кончится один из полиномов.
// а дальше проверяем, осталось ли в другом полиноме что-нибудь. если осталось, это нужно скопировать без всяких проверок.
// В ЗАПОЛНЕНИИ МАССИВА (строка 65 )
// в параметрах должно быть не size, а три значения (старт, конец, количество точек)
// в main это задается, дальше это передаем в качестве параметров,  непосредственно создавая объект Grid. и этот Grid передаем и на его основании делаем интерполяционный полином (в конструкторе, это правильно)
// У вас наверное должен быть полином (конструктор), который создает маном (степень и коэффициенты). И вы создаете бином из одного манома, второго манома и операции «+». И дальше вы будете работать с этими биномами, те. вы их будете перемножать, вычислять коэффициент, перемножать и умножать на коэффициент. 
// ТАКЖЕ РАСПИСАТЬ, как будет формироваться полином Лагранжа (с 74 строки). Формулы есть, их нужно сюда записать.
// В MAIN шаг (строка )
// шаг должен быть в 2 раза меньше, чем при формировании сетки.
// потому что вывод должен быть не только в узлах сетки, но и между ними.
// в отличие от заполнения сетки.