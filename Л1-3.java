// Класс Matrix
class Matrix {

  // Инициализация переменных
  private double[][] matrixArray; // Матрица (массив)
  private int rowAmount; // Количество строк
  private int columnAmount; // Количество столбцов
  private double epsilon; // Погрешность для проверки на равенство нулю
  private static final int NotFounded = -1; // Индекс, если строка с ненулевым не найдена
  private double[] solution; //Массив для получения решения


  // Метод печати матрицы
  public void Print() {
    // Цикл по строкам матрицы
    //    Цикл по столбцам матрицы
    //        Вывод элемента матрицы в консоль с форматированием
    //    Вывод новой строки
    // Вывод пустой строки
  }

  // Инициализация матрицы из файла
  public void Init(String s) throws FileNotFoundException {
    // Создаем объект File с именем файла s
    // Создаем объект Scanner для чтения файла
    // Создаем объект Pattern для разделения строк на элементы
    // Считываем первую строку файла
    // Разделяем строку на элементы и преобразуем их в соответствующие числа
    // Инициализация переменных rowAmount, columnAmount и epsilon
    // Вызываем метод Create() для создания двумерного массива matrixArray
    // Цикл по строкам матрицы
    //    Чтение строки файла и разделение ее на элементы
    //    Заполнение массива matrixArray данными из файла
    // Закрываем объект Scanner
  }

  // Приведение матрицы к треугольному виду
  public Results MakeTriangle() {
    // Цикл по итерациям (номер текущей итерации)
    //    Если текущая итерация превышает количество строк матрицы, прерываем цикл

    //    Вызов метода SwapFirstNotZeroLine() для обмена строк с нулевым элементом на диагонали
    //    Если результат обмена строк равен false (не с кем поменять строку, в которой обнаружили 0 на диагонали), 
    //    возвращаем "1" - система вырожденная

    //    Вызов метода RecalculateCoefficients() для пересчета коэффициентов после обнаружения ненулевого элемента
    //    Если матрица вырожденная (Дошли до конца, и последняя строка имеет нулевой элемент на диагонали), возвращаем либо
    //    "бесконечно много решений", либо "решений нет"

    // Если все хорошо, возвращаем "0" - решение единственное 
  }
  
  // Пересчет коэффициентов после обнаружения ненулевого элемента на диагонали
  private void RecalculateCoefficients(int currentRow, int nextRow) {
    // Цикл по столбцам матрицы
    //    Вычисление множителя для исключения переменной
    //    Обновление элементов строки с учетом множителя
    // TODO: РАСПИСАТЬ ЦИКЛ
  }

  // Обмен строк с ненулевым элементом
  private boolean SwapFirstNotZeroLine(int lineNumber) {
    // Если элемент на диагонали равен нулю
    //    Найти строку с ненулевым элементом на данной позиции
    //    Если такой строки нет, вернуть false
    //    Иначе, обменять строки местами
    // Вернуть true
  }

  // Проверка на наличие решений
  public void CheckSolutions(Results results) {
    // Передаем значение result из MakeTriangle
    // Вывод сообщения в зависимости от значения results
    На основе полученного result либо вывод соответствующей строки, либо выполнение обратной подстановки. 
    Если result 1 - система вырожденная
    Если result 0 - система имеет единственное решение
    Если result 2 - система имеет бесконечное количество решений
    Если result 3 - система не имеет решений
    далее либо вывод соответствующей строки, либо выполнение обратной подстановки. 
  }

  // Нахождение решений
  public double[] FindSolutions() {
    // Создаем массив решений размером rowAmount
    // Цикл по строкам матрицы в обратном порядке
    //    Вызываем метод GetSolution() для получения решения текущей строки
    //    Обновляем значение решения для текущей строки
    // Возвращаем массив решений
  }

  // Создание матрицы
  private void Create(int rowAmount, int columnAmount) {
    // Создаем массив массивов для матрицы
    // Цикл по строкам матрицы
    //    Создаем массив элементов для каждой строки
  }

  // Найти строку с ненулевым элементом
  private int FindLineWithNotZeroElement(int lineNumber) {
    // Цикл по строкам, начиная с lineNumber
    //    Если элемент строки на позиции lineNumber не равен нулю
    //        Возвращаем индекс строки
    // Возвращаем NotFounded
  }

  // Поменять строки местами
  private void SwapLines(int firstLine, int secondLine) {
    // Сохраняем ссылку на строку secondLine во временную переменную
    // Заменяем строку secondLine на firstLine
    // Заменяем строку firstLine на временную переменную (бывшую secondLine)
  }

  // Проверка на равенство элемента нулю
  private boolean IsZeroElement(double element) {
    // Сравниваем абсолютное значение элемента с epsilon
    // Возвращаем результат сравнения
  }

  // Умножение и вычитание строк
  private void MultiplicationAndSubtractionOfLine(double multiplier, int iterationNumber, int lineNumber) {
    // Цикл по столбцам матрицы
    //    Вычитаем произведение множителя на элемент строки iterationNumber из элемента строки lineNumber
    //    Если элемент строки lineNumber равен нулю, устанавливаем его значение в 0
  }

  // Получение решения
  private double GetSolution(int i) {
    //ВЫДЕЛЕНИЕ ПАМЯТИ ПОД МАССИВ SOLUTION
    // Инициализация переменной для суммы
    // Цикл по столбцам матрицы
    //    Увеличиваем сумму на произведение текущего решения на соответствующий элемент строки
    // Возвращаем сумму
  }
}

// Класс Main
class Main {

  public static void main(String[] args) {
    // Создаем объект mat типа Matrix
    // Загружаем матрицу из файла "src/Input.txt"
    // В случае ошибки FileNotFoundException, выводим сообщение "FILE NOT FOUND!!!"
    // Выводим матрицу на экран
    // Вызываем метод MakeTriangle для матрицы и сохраняем результат в переменную result
    // Выводим матрицу на экран после преобразования
    // Выводим результат операции (текстовое сообщение) с помощью метода GetResult
    // Если результат равен "система может быть продолжена"
    //    Вызываем метод CheckSolutions для матрицы и обновляем переменную result
    //    Если результат равен "система имеет единственное решение"
    //        Вызываем метод FindSolutions для матрицы и сохраняем результат в массив array
    //        Выводим массив решений на экран с помощью метода PrintResult
    //    Иначе
    //        Выводим результат операции (текстовое сообщение) с помощью метода GetResult
  }

  // Метод вывода результата на экран
  public static void GetResult(Results result) {
    // Используем оператор switch для вывода соответствующего текстового сообщения в зависимости от значения result
  }

  // Метод вывода массива решений на экран
  public static void PrintResult(double[] resultArray) {
    // Выводим текст "Результат: "
    // Цикл по элементам массива resultArray
    //    Выводим элемент массива на экран с форматированием
    // Выводим пустую строку
  }
}
// Возможные состояния:
// - Система уравнений имеет бесконечное количество решений
// - Система вырожденная
// - Система имеет единственное решение


//TODO:написать код, написать цикл(строка 57,в RecalculateCoefficients)
//код писать вместе планом, комментарии остаются
// public void Init(String s) throws FileNotFoundException { 
//     File file = new File(s);                      
//         Scanner scan = new Scanner(file);         
//         Pattern pat = Pattern.compile("[ \t]+");  
//         String str = scan.nextLine();             
//         String[] sn = pat.split(str);             
//         rowAmount = Integer.parseInt(sn[0]);      
//         columnAmount = Integer.parseInt(sn[1]) + 1; 
//         epsilon = Math.pow(10, -Double.parseDouble(sn[2]) - 1); 
//         this.Create(rowAmount, columnAmount);  
//         int i, j; 
//         for (i = 0; i < rowAmount; i++) {      
//             str = scan.nextLine();             
//             sn = pat.split(str); 
//             for (j = 0; j < columnAmount; j++) 
//                 matrixArray[i][j] = Double.parseDouble(sn[j]); 
//         } 
//         scan.close();  
//   }